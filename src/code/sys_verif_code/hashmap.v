(* autogenerated from sys_verif_code/hashmap *)
Require Export New.code.sync.

From New.golang Require Import defn.
Definition hashmap : go_string := "sys_verif_code/hashmap".

Module hashmap.

Module atomicPtr. Definition id : go_string := "sys_verif_code/hashmap.atomicPtr"%go. End atomicPtr.
Module HashMap. Definition id : go_string := "sys_verif_code/hashmap.HashMap"%go. End HashMap.

Section code.
Context `{ffi_syntax}.


Definition atomicPtr : go_type := structT [
  "mu" :: ptrT;
  "val" :: mapT uint64T uint64T
].
#[global] Typeclasses Opaque atomicPtr.
#[global] Opaque atomicPtr.

Definition newAtomicPtr : go_string := "sys_verif_code/hashmap.newAtomicPtr"%go.

(* go: hashmap.go:10:6 *)
Definition newAtomicPtrⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    return: (mem.alloc (let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$val" := (![type.mapT #uint64T #uint64T] "m") in
     struct.make #atomicPtr [{
       "mu" ::= "$mu";
       "val" ::= "$val"
     }]))).

(* go: hashmap.go:14:21 *)
Definition atomicPtr__loadⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (mem.alloc "a") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #atomicPtr #"mu"%go (![#ptrT] "a")))) #());;;
    let: "val" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (![type.mapT #uint64T #uint64T] (struct.field_ref #atomicPtr #"val"%go (![#ptrT] "a"))) in
    do:  ("val" <-[type.mapT #uint64T #uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #atomicPtr #"mu"%go (![#ptrT] "a")))) #());;;
    return: (![type.mapT #uint64T #uint64T] "val")).

(* go: hashmap.go:21:21 *)
Definition atomicPtr__storeⁱᵐᵖˡ : val :=
  λ: "a" "m",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "m" := (mem.alloc "m") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #atomicPtr #"mu"%go (![#ptrT] "a")))) #());;;
    let: "$r0" := (![type.mapT #uint64T #uint64T] "m") in
    do:  ((struct.field_ref #atomicPtr #"val"%go (![#ptrT] "a")) <-[type.mapT #uint64T #uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #atomicPtr #"mu"%go (![#ptrT] "a")))) #());;;
    return: #()).

Definition HashMap : go_type := structT [
  "clean" :: ptrT;
  "mu" :: ptrT
].
#[global] Typeclasses Opaque HashMap.
#[global] Opaque HashMap.

Definition NewHashMap : go_string := "sys_verif_code/hashmap.NewHashMap"%go.

(* go: hashmap.go:42:6 *)
Definition NewHashMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ("m" <-[type.mapT #uint64T #uint64T] "$r0");;;
    return: (mem.alloc (let: "$clean" := (let: "$a0" := (![type.mapT #uint64T #uint64T] "m") in
     (func_call #newAtomicPtr) "$a0") in
     let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     struct.make #HashMap [{
       "clean" ::= "$clean";
       "mu" ::= "$mu"
     }]))).

(* go: hashmap.go:47:19 *)
Definition HashMap__Loadⁱᵐᵖˡ : val :=
  λ: "h" "key",
    exception_do (let: "h" := (mem.alloc "h") in
    let: "key" := (mem.alloc "key") in
    let: "clean" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := ((method_call #(ptrT.id atomicPtr.id) #"load"%go (![#ptrT] (struct.field_ref #HashMap #"clean"%go (![#ptrT] "h")))) #()) in
    do:  ("clean" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "value" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #uint64T] "clean") (![#uint64T] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("value" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    return: (![#uint64T] "value", ![#boolT] "ok")).

Definition mapClone : go_string := "sys_verif_code/hashmap.mapClone"%go.

(* Clone the input map by copying all values.

   go: hashmap.go:54:6 *)
Definition mapCloneⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "clone" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ("clone" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#uint64T] "$value");;;
      do:  ("k" <-[#uint64T] "$key");;;
      let: "$r0" := (![#uint64T] "v") in
      do:  (map.insert (![type.mapT #uint64T #uint64T] "clone") (![#uint64T] "k") "$r0")));;;
    return: (![type.mapT #uint64T #uint64T] "clone")).

(* Assuming mu is held, return an owned copy of the current clean map.

   go: hashmap.go:63:19 *)
Definition HashMap__dirtyⁱᵐᵖˡ : val :=
  λ: "h" <>,
    exception_do (let: "h" := (mem.alloc "h") in
    let: "clean" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := ((method_call #(ptrT.id atomicPtr.id) #"load"%go (![#ptrT] (struct.field_ref #HashMap #"clean"%go (![#ptrT] "h")))) #()) in
    do:  ("clean" <-[type.mapT #uint64T #uint64T] "$r0");;;
    return: (let: "$a0" := (![type.mapT #uint64T #uint64T] "clean") in
     (func_call #mapClone) "$a0")).

(* go: hashmap.go:68:19 *)
Definition HashMap__Storeⁱᵐᵖˡ : val :=
  λ: "h" "key" "value",
    exception_do (let: "h" := (mem.alloc "h") in
    let: "value" := (mem.alloc "value") in
    let: "key" := (mem.alloc "key") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #HashMap #"mu"%go (![#ptrT] "h")))) #());;;
    let: "dirty" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := ((method_call #(ptrT.id HashMap.id) #"dirty"%go (![#ptrT] "h")) #()) in
    do:  ("dirty" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "value") in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "dirty") (![#uint64T] "key") "$r0");;;
    do:  (let: "$a0" := (![type.mapT #uint64T #uint64T] "dirty") in
    (method_call #(ptrT.id atomicPtr.id) #"store"%go (![#ptrT] (struct.field_ref #HashMap #"clean"%go (![#ptrT] "h")))) "$a0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #HashMap #"mu"%go (![#ptrT] "h")))) #());;;
    return: #()).

(* go: hashmap.go:76:19 *)
Definition HashMap__Deleteⁱᵐᵖˡ : val :=
  λ: "h" "key",
    exception_do (let: "h" := (mem.alloc "h") in
    let: "key" := (mem.alloc "key") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #HashMap #"mu"%go (![#ptrT] "h")))) #());;;
    let: "dirty" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := ((method_call #(ptrT.id HashMap.id) #"dirty"%go (![#ptrT] "h")) #()) in
    do:  ("dirty" <-[type.mapT #uint64T #uint64T] "$r0");;;
    do:  (let: "$a0" := (![type.mapT #uint64T #uint64T] "dirty") in
    let: "$a1" := (![#uint64T] "key") in
    map.delete "$a0" "$a1");;;
    do:  (let: "$a0" := (![type.mapT #uint64T #uint64T] "dirty") in
    (method_call #(ptrT.id atomicPtr.id) #"store"%go (![#ptrT] (struct.field_ref #HashMap #"clean"%go (![#ptrT] "h")))) "$a0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #HashMap #"mu"%go (![#ptrT] "h")))) #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(newAtomicPtr, newAtomicPtrⁱᵐᵖˡ); (NewHashMap, NewHashMapⁱᵐᵖˡ); (mapClone, mapCloneⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(atomicPtr.id, []); (ptrT.id atomicPtr.id, [("load"%go, atomicPtr__loadⁱᵐᵖˡ); ("store"%go, atomicPtr__storeⁱᵐᵖˡ)]); (HashMap.id, []); (ptrT.id HashMap.id, [("Delete"%go, HashMap__Deleteⁱᵐᵖˡ); ("Load"%go, HashMap__Loadⁱᵐᵖˡ); ("Store"%go, HashMap__Storeⁱᵐᵖˡ); ("dirty"%go, HashMap__dirtyⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo hashmap.hashmap :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #hashmap.hashmap (λ: <>,
      exception_do (do:  (sync.initialize' #());;;
      do:  (package.alloc hashmap.hashmap #()))
      ).

End code.
End hashmap.
