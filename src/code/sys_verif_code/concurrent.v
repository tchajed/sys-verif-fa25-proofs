(* autogenerated from sys_verif_code/concurrent *)
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.sync.
Require Export New.code.sys_verif_code.concurrent.barrier.

From New.golang Require Import defn.
Definition concurrent : go_string := "sys_verif_code/concurrent".

Module concurrent.

Module AtomicInt. Definition id : go_string := "sys_verif_code/concurrent.AtomicInt"%go. End AtomicInt.

Section code.
Context `{ffi_syntax}.


Definition AtomicInt : go_type := structT [
  "x" :: uint64T;
  "mu" :: ptrT
].
#[global] Typeclasses Opaque AtomicInt.
#[global] Opaque AtomicInt.

Definition NewAtomicInt : go_string := "sys_verif_code/concurrent.NewAtomicInt"%go.

(* go: concurrent.go:17:6 *)
Definition NewAtomicIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$x" := #(W64 0) in
     let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     struct.make #AtomicInt [{
       "x" ::= "$x";
       "mu" ::= "$mu"
     }]))).

(* go: concurrent.go:21:21 *)
Definition AtomicInt__Getⁱᵐᵖˡ : val :=
  λ: "i" <>,
    exception_do (let: "i" := (mem.alloc "i") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #AtomicInt #"mu"%go (![#ptrT] "i")))) #());;;
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #AtomicInt #"x"%go (![#ptrT] "i"))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #AtomicInt #"mu"%go (![#ptrT] "i")))) #());;;
    return: (![#uint64T] "x")).

(* go: concurrent.go:28:21 *)
Definition AtomicInt__Incⁱᵐᵖˡ : val :=
  λ: "i" "y",
    exception_do (let: "i" := (mem.alloc "i") in
    let: "y" := (mem.alloc "y") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #AtomicInt #"mu"%go (![#ptrT] "i")))) #());;;
    do:  ((struct.field_ref #AtomicInt #"x"%go (![#ptrT] "i")) <-[#uint64T] ((![#uint64T] (struct.field_ref #AtomicInt #"x"%go (![#ptrT] "i"))) + (![#uint64T] "y")));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #AtomicInt #"mu"%go (![#ptrT] "i")))) #());;;
    return: #()).

Definition ParallelAdd1 : go_string := "sys_verif_code/concurrent.ParallelAdd1"%go.

(* go: concurrent.go:34:6 *)
Definition ParallelAdd1ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #NewAtomicInt) #()) in
    do:  ("i" <-[#ptrT] "$r0");;;
    let: "h1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  (let: "$a0" := #(W64 2) in
      (method_call #(ptrT.id AtomicInt.id) #"Inc"%go (![#ptrT] "i")) "$a0");;;
      return: #())
      ) in
    (func_call #std.Spawn) "$a0") in
    do:  ("h1" <-[#ptrT] "$r0");;;
    let: "h2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  (let: "$a0" := #(W64 2) in
      (method_call #(ptrT.id AtomicInt.id) #"Inc"%go (![#ptrT] "i")) "$a0");;;
      return: #())
      ) in
    (func_call #std.Spawn) "$a0") in
    do:  ("h2" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] "h1")) #());;;
    do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] "h2")) #());;;
    return: ((method_call #(ptrT.id AtomicInt.id) #"Get"%go (![#ptrT] "i")) #())).

Definition ParallelAdd2 : go_string := "sys_verif_code/concurrent.ParallelAdd2"%go.

(* go: concurrent.go:47:6 *)
Definition ParallelAdd2ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #barrier.New) #()) in
    do:  ("b" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    (method_call #(ptrT.id barrier.Barrier.id) #"Add"%go (![#ptrT] "b")) "$a0");;;
    do:  (let: "$a0" := #(W64 1) in
    (method_call #(ptrT.id barrier.Barrier.id) #"Add"%go (![#ptrT] "b")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      let: "$r0" := (let: "$a0" := (![#uint64T] "x") in
      let: "$a1" := #(W64 2) in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ("x" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      do:  ((method_call #(ptrT.id barrier.Barrier.id) #"Done"%go (![#ptrT] "b")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      let: "$r0" := (let: "$a0" := (![#uint64T] "x") in
      let: "$a1" := #(W64 2) in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ("x" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      do:  ((method_call #(ptrT.id barrier.Barrier.id) #"Done"%go (![#ptrT] "b")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((method_call #(ptrT.id barrier.Barrier.id) #"Wait"%go (![#ptrT] "b")) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    let: "x_now" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "x") in
    do:  ("x_now" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: (![#uint64T] "x_now")).

Definition ParallelAdd3 : go_string := "sys_verif_code/concurrent.ParallelAdd3"%go.

(* go: concurrent.go:73:6 *)
Definition ParallelAdd3ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    let: "h1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 2)));;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      return: #())
      ) in
    (func_call #std.Spawn) "$a0") in
    do:  ("h1" <-[#ptrT] "$r0");;;
    let: "h2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 2)));;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      return: #())
      ) in
    (func_call #std.Spawn) "$a0") in
    do:  ("h2" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] "h1")) #());;;
    do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] "h2")) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "i") in
    do:  ("y" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: (![#uint64T] "y")).

Definition ParallelAdd_Nthreads : go_string := "sys_verif_code/concurrent.ParallelAdd_Nthreads"%go.

(* go: concurrent.go:94:6 *)
Definition ParallelAdd_Nthreadsⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    let: "handles" := (mem.alloc (type.zero_val #sliceT)) in
    (let: "thread_i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("thread_i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "thread_i") < (![#uint64T] "n")); (λ: <>, do:  ("thread_i" <-[#uint64T] ((![#uint64T] "thread_i") + #(W64 1)))) := λ: <>,
      let: "h" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (λ: <>,
        exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
        let: "$r0" := (let: "$a0" := (![#uint64T] "i") in
        let: "$a1" := #(W64 2) in
        (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
        do:  ("i" <-[#uint64T] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
        return: #())
        ) in
      (func_call #std.Spawn) "$a0") in
      do:  ("h" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "handles") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "h") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("handles" <-[#sliceT] "$r0")));;;
    let: "$range" := (![#sliceT] "handles") in
    (let: "h" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("h" <-[#ptrT] "$value");;;
      do:  "$key";;;
      do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] "h")) #())));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "i") in
    do:  ("y" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: (![#uint64T] "y")).

Definition SetX : go_string := "sys_verif_code/concurrent.SetX"%go.

(* go: examples.go:5:6 *)
Definition SetXⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$r0" := #(W64 1) in
    do:  ((![#ptrT] "x") <-[#uint64T] "$r0");;;
    return: #()).

Definition NoGo : go_string := "sys_verif_code/concurrent.NoGo"%go.

(* go: examples.go:9:6 *)
Definition NoGoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    do:  (let: "$a0" := "x" in
    (func_call #SetX) "$a0");;;
    return: #()).

Definition FirstGo : go_string := "sys_verif_code/concurrent.FirstGo"%go.

(* go: examples.go:14:6 *)
Definition FirstGoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := "x" in
      (func_call #SetX) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

Definition FirstLock : go_string := "sys_verif_code/concurrent.FirstLock"%go.

(* go: examples.go:21:6 *)
Definition FirstLockⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      let: "$r0" := #(W64 1) in
      do:  ("x" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "x") in
    do:  ("y" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: (![#uint64T] "y")).

Definition LockedCounter : go_string := "sys_verif_code/concurrent.LockedCounter"%go.

(* go: examples.go:35:6 *)
Definition LockedCounterⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "counter" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("counter" <-[#ptrT] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      let: "$r0" := ((![#uint64T] (![#ptrT] "counter")) + #(W64 2)) in
      do:  ((![#ptrT] "counter") <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
      let: "$r0" := ((![#uint64T] (![#ptrT] "counter")) + #(W64 2)) in
      do:  ((![#ptrT] "counter") <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] "counter")) in
    do:  ("y" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: (![#uint64T] "y")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewAtomicInt, NewAtomicIntⁱᵐᵖˡ); (ParallelAdd1, ParallelAdd1ⁱᵐᵖˡ); (ParallelAdd2, ParallelAdd2ⁱᵐᵖˡ); (ParallelAdd3, ParallelAdd3ⁱᵐᵖˡ); (ParallelAdd_Nthreads, ParallelAdd_Nthreadsⁱᵐᵖˡ); (SetX, SetXⁱᵐᵖˡ); (NoGo, NoGoⁱᵐᵖˡ); (FirstGo, FirstGoⁱᵐᵖˡ); (FirstLock, FirstLockⁱᵐᵖˡ); (LockedCounter, LockedCounterⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(AtomicInt.id, []); (ptrT.id AtomicInt.id, [("Get"%go, AtomicInt__Getⁱᵐᵖˡ); ("Inc"%go, AtomicInt__Incⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo concurrent.concurrent :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.sys_verif_code.concurrent.barrier.barrier; code.github_com.goose_lang.std.std];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #concurrent.concurrent (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (barrier.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc concurrent.concurrent #()))
      ).

End code.
End concurrent.
