(* autogenerated from sys_verif_code/heap *)
Require Export New.code.github_com.goose_lang.std.

From New.golang Require Import defn.
Definition heap : go_string := "sys_verif_code/heap".

Module heap.

Module S1. Definition id : go_string := "sys_verif_code/heap.S1"%go. End S1.
Module Stack. Definition id : go_string := "sys_verif_code/heap.Stack"%go. End Stack.
Module Queue. Definition id : go_string := "sys_verif_code/heap.Queue"%go. End Queue.
Module SearchTree. Definition id : go_string := "sys_verif_code/heap.SearchTree"%go. End SearchTree.
Module Person. Definition id : go_string := "sys_verif_code/heap.Person"%go. End Person.
Module Rect. Definition id : go_string := "sys_verif_code/heap.Rect"%go. End Rect.

Section code.
Context `{ffi_syntax}.


Definition BinarySearch : go_string := "sys_verif_code/heap.BinarySearch"%go.

(* BinarySearch looks for needle in the sorted list s. It returns (index, found)
   where if found = false, needle is not present in s, and if found = true, s[index]
   == needle.

   If needle appears multiple times in s, no guarantees are made about which of
   those indices is returned.

   go: binary_search.go:9:6 *)
Definition BinarySearchⁱᵐᵖˡ : val :=
  λ: "s" "needle",
    exception_do (let: "needle" := (mem.alloc "needle") in
    let: "s" := (mem.alloc "s") in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0") in
    do:  ("j" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
      let: "mid" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "i") + (((![#intT] "j") - (![#intT] "i")) `quots` #(W64 2))) in
      do:  ("mid" <-[#intT] "$r0");;;
      (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "s") (![#intT] "mid"))) < (![#uint64T] "needle")
      then
        let: "$r0" := ((![#intT] "mid") + #(W64 1)) in
        do:  ("i" <-[#intT] "$r0")
      else
        let: "$r0" := (![#intT] "mid") in
        do:  ("j" <-[#intT] "$r0")));;;
    (if: int_lt (![#intT] "i") (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0")
    then return: (![#intT] "i", (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "s") (![#intT] "i"))) = (![#uint64T] "needle"))
    else do:  #());;;
    return: (![#intT] "i", #false)).

Definition ExampleA : go_string := "sys_verif_code/heap.ExampleA"%go.

(* go: exercises.go:5:6 *)
Definition ExampleAⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (mem.alloc "z") in
    let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: ![#boolT] (![#ptrT] "x")
    then
      let: "$r0" := (![#uint64T] "z") in
      do:  ((![#ptrT] "y") <-[#uint64T] "$r0")
    else
      let: "$r0" := #(W64 0) in
      do:  ((![#ptrT] "y") <-[#uint64T] "$r0"));;;
    return: #()).

Definition ExampleB : go_string := "sys_verif_code/heap.ExampleB"%go.

(* go: exercises.go:13:6 *)
Definition ExampleBⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (mem.alloc "z") in
    let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: ![#boolT] (![#ptrT] "x")
    then
      do:  (let: "$a0" := ((![#uint64T] "z") = #(W64 0)) in
      (func_call #std.Assert) "$a0");;;
      let: "$r0" := (![#uint64T] "z") in
      do:  ((![#ptrT] "y") <-[#uint64T] "$r0")
    else
      let: "$r0" := #(W64 0) in
      do:  ((![#ptrT] "y") <-[#uint64T] "$r0"));;;
    return: #()).

Definition S1 : go_type := structT [
  "a" :: uint64T;
  "b" :: sliceT
].
#[global] Typeclasses Opaque S1.
#[global] Opaque S1.

Definition ExampleC : go_string := "sys_verif_code/heap.ExampleC"%go.

(* go: exercises.go:27:6 *)
Definition ExampleCⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: (![#uint64T] (struct.field_ref #S1 #"a"%go (![#ptrT] "x"))) = #(W64 0)
    then return: (#"false"%go)
    else do:  #());;;
    return: (#"true"%go)).

Definition ExampleD : go_string := "sys_verif_code/heap.ExampleD"%go.

(* go: exercises.go:34:6 *)
Definition ExampleDⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := ((![#uint64T] (struct.field_ref #S1 #"a"%go (![#ptrT] "x"))) = (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #S1 #"b"%go (![#ptrT] "x"))) in
    slice.len "$a0"))) in
    (func_call #std.Assert) "$a0");;;
    return: (![#byteT] (slice.elem_ref #byteT (![#sliceT] (struct.field_ref #S1 #"b"%go (![#ptrT] "x"))) #(W64 0)))).

Definition ExampleE : go_string := "sys_verif_code/heap.ExampleE"%go.

(* go: exercises.go:39:6 *)
Definition ExampleEⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "$r0" := (![#uint64T] (struct.field_ref #S1 #"a"%go "x")) in
    do:  ((struct.field_ref #S1 #"a"%go (![#ptrT] "y")) <-[#uint64T] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #S1 #"b"%go (![#ptrT] "y")) <-[#sliceT] "$r0");;;
    return: #()).

Definition collatzF : go_string := "sys_verif_code/heap.collatzF"%go.

(* go: exercises.go:44:6 *)
Definition collatzFⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: ((![#uint64T] "x") `rem` #(W64 2)) = #(W64 0)
    then return: ((![#uint64T] "x") `quot` #(W64 2))
    else return: ((#(W64 3) * (![#uint64T] "x")) + #(W64 1)))).

Definition collatzIter : go_string := "sys_verif_code/heap.collatzIter"%go.

(* go: exercises.go:52:6 *)
Definition collatzIterⁱᵐᵖˡ : val :=
  λ: "x" "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "x" := (mem.alloc "x") in
    (if: (![#uint64T] "n") = #(W64 0)
    then return: (![#uint64T] "x")
    else
      return: (let: "$a0" := (let: "$a0" := (![#uint64T] "x") in
       (func_call #collatzF) "$a0") in
       let: "$a1" := ((![#uint64T] "n") - #(W64 1)) in
       (func_call #collatzIter) "$a0" "$a1"))).

Definition ExampleG : go_string := "sys_verif_code/heap.ExampleG"%go.

(* go: exercises.go:60:6 *)
Definition ExampleGⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := #(W64 12) in
     let: "$a1" := #(W64 9) in
     (func_call #collatzIter) "$a0" "$a1")).

Definition Swap : go_string := "sys_verif_code/heap.Swap"%go.

(* go: heap.go:5:6 *)
Definition Swapⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "old_y" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (![#intT] (![#ptrT] "y")) in
    do:  ("old_y" <-[#intT] "$r0");;;
    let: "$r0" := (![#intT] (![#ptrT] "x")) in
    do:  ((![#ptrT] "y") <-[#intT] "$r0");;;
    let: "$r0" := (![#intT] "old_y") in
    do:  ((![#ptrT] "x") <-[#intT] "$r0");;;
    return: #()).

Definition IgnoreOne : go_string := "sys_verif_code/heap.IgnoreOne"%go.

(* IgnoreOne has a specification that shows it does not need ownership of
   its second argument.

   go: heap.go:13:6 *)
Definition IgnoreOneⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := ((![#intT] (![#ptrT] "x")) = #(W64 0)) in
    (func_call #std.Assert) "$a0");;;
    let: "$r0" := #(W64 42) in
    do:  ((![#ptrT] "x") <-[#intT] "$r0");;;
    return: #()).

Definition UseIgnoreOneOwnership : go_string := "sys_verif_code/heap.UseIgnoreOneOwnership"%go.

(* UseIgnoreOneOwnership uses IgnoreOneLocF and can be verified using its
   specification.

   go: heap.go:20:6 *)
Definition UseIgnoreOneOwnershipⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[#intT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 42) in
    do:  ("y" <-[#intT] "$r0");;;
    do:  (let: "$a0" := "x" in
    let: "$a1" := "y" in
    (func_call #IgnoreOne) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![#intT] "x") = (![#intT] "y")) in
    (func_call #std.Assert) "$a0");;;
    return: #()).

Definition CopySlice : go_string := "sys_verif_code/heap.CopySlice"%go.

(* CopySlice copies from src to dst

   dst must be at least as long as src

   go: heap.go:30:6 *)
Definition CopySliceⁱᵐᵖˡ : val :=
  λ: "dst" "src",
    exception_do (let: "src" := (mem.alloc "src") in
    let: "dst" := (mem.alloc "dst") in
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "dst") in
    slice.len "$a0")) in
    do:  ("l" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "l")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "src") (![#uint64T] "i"))) in
      do:  ((slice.elem_ref #byteT (![#sliceT] "dst") (![#uint64T] "i")) <-[#byteT] "$r0")));;;
    return: #()).

Definition StackEscape : go_string := "sys_verif_code/heap.StackEscape"%go.

(* StackEscape shows a local variable being promoted to the heap.

   This illustrates both how Go works and ownership principles.

   go: heap.go:40:6 *)
Definition StackEscapeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 42) in
    do:  ("x" <-[#intT] "$r0");;;
    return: ("x")).

Definition FindMajority : go_string := "sys_verif_code/heap.FindMajority"%go.

(* FindMajority finds an `x` that appears in the slice `a` more than half the
   time.

   That is, if there is some x that appears in a strictly more than `len(a)/2`
   times, then `FindMajority` will return it.

   This implementation of the algorithm comes from _Program Proofs_ by K. Rustan
   M. Leino in chapter 13.7.

   go: majority_vote.go:11:6 *)
Definition FindMajorityⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "k" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := (![#uint32T] (slice.elem_ref #uint32T (![#sliceT] "a") #(W64 0))) in
    do:  ("k" <-[#uint32T] "$r0");;;
    let: "lo" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("lo" <-[#uint64T] "$r0");;;
    let: "hi" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("hi" <-[#uint64T] "$r0");;;
    let: "c" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("c" <-[#uint64T] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "a") in
    slice.len "$a0")) in
    do:  ("l" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "hi") < (![#uint64T] "l")); (λ: <>, #()) := λ: <>,
      (if: (![#uint32T] (slice.elem_ref #uint32T (![#sliceT] "a") (![#uint64T] "hi"))) = (![#uint32T] "k")
      then
        let: "$r0" := ((![#uint64T] "hi") + #(W64 1)) in
        let: "$r1" := ((![#uint64T] "c") + #(W64 1)) in
        do:  ("hi" <-[#uint64T] "$r0");;;
        do:  ("c" <-[#uint64T] "$r1")
      else
        (if: (((![#uint64T] "hi") + #(W64 1)) - (![#uint64T] "lo")) < (#(W64 2) * (![#uint64T] "c"))
        then do:  ("hi" <-[#uint64T] ((![#uint64T] "hi") + #(W64 1)))
        else
          do:  ("hi" <-[#uint64T] ((![#uint64T] "hi") + #(W64 1)));;;
          (if: (![#uint64T] "hi") = (![#uint64T] "l")
          then break: #()
          else do:  #());;;
          let: "$r0" := (![#uint32T] (slice.elem_ref #uint32T (![#sliceT] "a") (![#uint64T] "hi"))) in
          let: "$r1" := (![#uint64T] "hi") in
          let: "$r2" := ((![#uint64T] "hi") + #(W64 1)) in
          let: "$r3" := #(W64 1) in
          do:  ("k" <-[#uint32T] "$r0");;;
          do:  ("lo" <-[#uint64T] "$r1");;;
          do:  ("hi" <-[#uint64T] "$r2");;;
          do:  ("c" <-[#uint64T] "$r3"))));;;
    return: (![#uint32T] "k")).

Definition Stack : go_type := structT [
  "elements" :: sliceT
].
#[global] Typeclasses Opaque Stack.
#[global] Opaque Stack.

Definition NewStack : go_string := "sys_verif_code/heap.NewStack"%go.

(* go: queue.go:7:6 *)
Definition NewStackⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$elements" := #slice.nil in
     struct.make #Stack [{
       "elements" ::= "$elements"
     }]))).

(* go: queue.go:13:17 *)
Definition Stack__Pushⁱᵐᵖˡ : val :=
  λ: "s" "x",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "x" := (mem.alloc "x") in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![#uint64T] "x") in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ((struct.field_ref #Stack #"elements"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    return: #()).

(* Pop returns the most recently pushed element. The boolean indicates success,
   which is false if the stack was empty.

   go: queue.go:19:17 *)
Definition Stack__Popⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) ((let: "$a0" := (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) in
    slice.len "$a0") - #(W64 1)))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) in
    slice.slice #uint64T "$s" #(W64 0) ((let: "$a0" := (![#sliceT] (struct.field_ref #Stack #"elements"%go (![#ptrT] "s"))) in
    slice.len "$a0") - #(W64 1))) in
    do:  ((struct.field_ref #Stack #"elements"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    return: (![#uint64T] "x", #true)).

Definition Queue : go_type := structT [
  "back" :: ptrT;
  "front" :: ptrT
].
#[global] Typeclasses Opaque Queue.
#[global] Opaque Queue.

Definition NewQueue : go_string := "sys_verif_code/heap.NewQueue"%go.

(* go: queue.go:33:6 *)
Definition NewQueueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$back" := ((func_call #NewStack) #()) in
     let: "$front" := ((func_call #NewStack) #()) in
     struct.make #Queue [{
       "back" ::= "$back";
       "front" ::= "$front"
     }])).

(* go: queue.go:40:16 *)
Definition Queue__Pushⁱᵐᵖˡ : val :=
  λ: "q" "x",
    exception_do (let: "q" := (mem.alloc "q") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := (![#uint64T] "x") in
    (method_call #(ptrT.id Stack.id) #"Push"%go (![#ptrT] (struct.field_ref #Queue #"back"%go "q"))) "$a0");;;
    return: #()).

(* go: queue.go:44:16 *)
Definition Queue__emptyBackⁱᵐᵖˡ : val :=
  λ: "q" <>,
    exception_do (let: "q" := (mem.alloc "q") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "x" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Stack.id) #"Pop"%go (![#ptrT] (struct.field_ref #Queue #"back"%go "q"))) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("x" <-[#uint64T] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then
        do:  (let: "$a0" := (![#uint64T] "x") in
        (method_call #(ptrT.id Stack.id) #"Push"%go (![#ptrT] (struct.field_ref #Queue #"front"%go "q"))) "$a0")
      else break: #()));;;
    return: #()).

(* go: queue.go:55:16 *)
Definition Queue__Popⁱᵐᵖˡ : val :=
  λ: "q" <>,
    exception_do (let: "q" := (mem.alloc "q") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Stack.id) #"Pop"%go (![#ptrT] (struct.field_ref #Queue #"front"%go "q"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (![#uint64T] "x", #true)
    else do:  #());;;
    do:  ((method_call #Queue.id #"emptyBack"%go (![#Queue] "q")) #());;;
    let: "ok2" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Stack.id) #"Pop"%go (![#ptrT] (struct.field_ref #Queue #"front"%go "q"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("ok2" <-[#boolT] "$r1");;;
    return: (![#uint64T] "x", ![#boolT] "ok2")).

Definition SearchTree : go_type := structT [
  "key" :: uint64T;
  "left" :: ptrT;
  "right" :: ptrT
].
#[global] Typeclasses Opaque SearchTree.
#[global] Opaque SearchTree.

Definition NewSearchTree : go_string := "sys_verif_code/heap.NewSearchTree"%go.

(* go: search_tree.go:9:6 *)
Definition NewSearchTreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#null)).

Definition singletonTree : go_string := "sys_verif_code/heap.singletonTree"%go.

(* go: search_tree.go:13:6 *)
Definition singletonTreeⁱᵐᵖˡ : val :=
  λ: "key",
    exception_do (let: "key" := (mem.alloc "key") in
    return: (mem.alloc (let: "$key" := (![#uint64T] "key") in
     let: "$left" := #null in
     let: "$right" := #null in
     struct.make #SearchTree [{
       "key" ::= "$key";
       "left" ::= "$left";
       "right" ::= "$right"
     }]))).

(* go: search_tree.go:17:22 *)
Definition SearchTree__Insertⁱᵐᵖˡ : val :=
  λ: "t" "key",
    exception_do (let: "t" := (mem.alloc "t") in
    let: "key" := (mem.alloc "key") in
    (if: (![#ptrT] "t") = #null
    then
      return: (let: "$a0" := (![#uint64T] "key") in
       (func_call #singletonTree) "$a0")
    else do:  #());;;
    (if: (![#uint64T] "key") < (![#uint64T] (struct.field_ref #SearchTree #"key"%go (![#ptrT] "t")))
    then
      let: "$r0" := (let: "$a0" := (![#uint64T] "key") in
      (method_call #(ptrT.id SearchTree.id) #"Insert"%go (![#ptrT] (struct.field_ref #SearchTree #"left"%go (![#ptrT] "t")))) "$a0") in
      do:  ((struct.field_ref #SearchTree #"left"%go (![#ptrT] "t")) <-[#ptrT] "$r0")
    else
      (if: (![#uint64T] (struct.field_ref #SearchTree #"key"%go (![#ptrT] "t"))) < (![#uint64T] "key")
      then
        let: "$r0" := (let: "$a0" := (![#uint64T] "key") in
        (method_call #(ptrT.id SearchTree.id) #"Insert"%go (![#ptrT] (struct.field_ref #SearchTree #"right"%go (![#ptrT] "t")))) "$a0") in
        do:  ((struct.field_ref #SearchTree #"right"%go (![#ptrT] "t")) <-[#ptrT] "$r0")
      else do:  #()));;;
    return: (![#ptrT] "t")).

(* go: search_tree.go:31:22 *)
Definition SearchTree__Containsⁱᵐᵖˡ : val :=
  λ: "t" "key",
    exception_do (let: "t" := (mem.alloc "t") in
    let: "key" := (mem.alloc "key") in
    (if: (![#ptrT] "t") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#uint64T] "key") = (![#uint64T] (struct.field_ref #SearchTree #"key"%go (![#ptrT] "t")))
    then return: (#true)
    else do:  #());;;
    (if: (![#uint64T] "key") < (![#uint64T] (struct.field_ref #SearchTree #"key"%go (![#ptrT] "t")))
    then
      return: (let: "$a0" := (![#uint64T] "key") in
       (method_call #(ptrT.id SearchTree.id) #"Contains"%go (![#ptrT] (struct.field_ref #SearchTree #"left"%go (![#ptrT] "t")))) "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![#uint64T] "key") in
     (method_call #(ptrT.id SearchTree.id) #"Contains"%go (![#ptrT] (struct.field_ref #SearchTree #"right"%go (![#ptrT] "t")))) "$a0")).

Definition Person : go_type := structT [
  "FirstName" :: stringT;
  "LastName" :: stringT;
  "Age" :: uint64T
].
#[global] Typeclasses Opaque Person.
#[global] Opaque Person.

(* go: struct.go:9:17 *)
Definition Person__Nameⁱᵐᵖˡ : val :=
  λ: "p" <>,
    exception_do (let: "p" := (mem.alloc "p") in
    return: (((![#stringT] (struct.field_ref #Person #"FirstName"%go "p")) + #" "%go) + (![#stringT] (struct.field_ref #Person #"LastName"%go "p")))).

(* go: struct.go:13:18 *)
Definition Person__Olderⁱᵐᵖˡ : val :=
  λ: "p" "delta",
    exception_do (let: "p" := (mem.alloc "p") in
    let: "delta" := (mem.alloc "delta") in
    do:  ((struct.field_ref #Person #"Age"%go (![#ptrT] "p")) <-[#uint64T] ((![#uint64T] (struct.field_ref #Person #"Age"%go (![#ptrT] "p"))) + (![#uint64T] "delta")));;;
    return: #()).

(* go: struct.go:17:18 *)
Definition Person__GetAgeⁱᵐᵖˡ : val :=
  λ: "p" <>,
    exception_do (let: "p" := (mem.alloc "p") in
    return: (struct.field_ref #Person #"Age"%go (![#ptrT] "p"))).

Definition ExamplePerson : go_string := "sys_verif_code/heap.ExamplePerson"%go.

(* go: struct.go:21:6 *)
Definition ExamplePersonⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$FirstName" := #"Ada"%go in
     let: "$LastName" := #"Lovelace"%go in
     let: "$Age" := #(W64 25) in
     struct.make #Person [{
       "FirstName" ::= "$FirstName";
       "LastName" ::= "$LastName";
       "Age" ::= "$Age"
     }])).

Definition ExamplePersonRef : go_string := "sys_verif_code/heap.ExamplePersonRef"%go.

(* go: struct.go:29:6 *)
Definition ExamplePersonRefⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$FirstName" := #"Ada"%go in
     let: "$LastName" := #"Lovelace"%go in
     let: "$Age" := #(W64 25) in
     struct.make #Person [{
       "FirstName" ::= "$FirstName";
       "LastName" ::= "$LastName";
       "Age" ::= "$Age"
     }]))).

(* go: struct.go:37:17 *)
Definition Person__BuggySetAgeⁱᵐᵖˡ : val :=
  λ: "p" <>,
    exception_do (let: "p" := (mem.alloc "p") in
    do:  ((struct.field_ref #Person #"Age"%go "p") <-[#uint64T] ((![#uint64T] (struct.field_ref #Person #"Age"%go "p")) + #(W64 1)));;;
    return: #()).

Definition Rect : go_type := structT [
  "Width" :: uint64T;
  "Height" :: uint64T
].
#[global] Typeclasses Opaque Rect.
#[global] Opaque Rect.

(* go: struct.go:46:15 *)
Definition Rect__Areaⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    return: ((![#uint64T] (struct.field_ref #Rect #"Width"%go "r")) * (![#uint64T] (struct.field_ref #Rect #"Height"%go "r")))).

(* go: struct.go:50:15 *)
Definition Rect__IsSquareⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    return: ((![#uint64T] (struct.field_ref #Rect #"Width"%go "r")) = (![#uint64T] (struct.field_ref #Rect #"Height"%go "r")))).

(* go: struct.go:54:16 *)
Definition Rect__MakeSquareⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    let: "$r0" := (![#uint64T] (struct.field_ref #Rect #"Width"%go (![#ptrT] "r"))) in
    do:  ((struct.field_ref #Rect #"Height"%go (![#ptrT] "r")) <-[#uint64T] "$r0");;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(BinarySearch, BinarySearchⁱᵐᵖˡ); (ExampleA, ExampleAⁱᵐᵖˡ); (ExampleB, ExampleBⁱᵐᵖˡ); (ExampleC, ExampleCⁱᵐᵖˡ); (ExampleD, ExampleDⁱᵐᵖˡ); (ExampleE, ExampleEⁱᵐᵖˡ); (collatzF, collatzFⁱᵐᵖˡ); (collatzIter, collatzIterⁱᵐᵖˡ); (ExampleG, ExampleGⁱᵐᵖˡ); (Swap, Swapⁱᵐᵖˡ); (IgnoreOne, IgnoreOneⁱᵐᵖˡ); (UseIgnoreOneOwnership, UseIgnoreOneOwnershipⁱᵐᵖˡ); (CopySlice, CopySliceⁱᵐᵖˡ); (StackEscape, StackEscapeⁱᵐᵖˡ); (FindMajority, FindMajorityⁱᵐᵖˡ); (NewStack, NewStackⁱᵐᵖˡ); (NewQueue, NewQueueⁱᵐᵖˡ); (NewSearchTree, NewSearchTreeⁱᵐᵖˡ); (singletonTree, singletonTreeⁱᵐᵖˡ); (ExamplePerson, ExamplePersonⁱᵐᵖˡ); (ExamplePersonRef, ExamplePersonRefⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(S1.id, []); (ptrT.id S1.id, []); (Stack.id, []); (ptrT.id Stack.id, [("Pop"%go, Stack__Popⁱᵐᵖˡ); ("Push"%go, Stack__Pushⁱᵐᵖˡ)]); (Queue.id, [("Pop"%go, Queue__Popⁱᵐᵖˡ); ("Push"%go, Queue__Pushⁱᵐᵖˡ); ("emptyBack"%go, Queue__emptyBackⁱᵐᵖˡ)]); (ptrT.id Queue.id, [("Pop"%go, (λ: "$r",
                 method_call #Queue.id #"Pop"%go (![#Queue] "$r")
                 )%V); ("Push"%go, (λ: "$r",
                 method_call #Queue.id #"Push"%go (![#Queue] "$r")
                 )%V); ("emptyBack"%go, (λ: "$r",
                 method_call #Queue.id #"emptyBack"%go (![#Queue] "$r")
                 )%V)]); (SearchTree.id, []); (ptrT.id SearchTree.id, [("Contains"%go, SearchTree__Containsⁱᵐᵖˡ); ("Insert"%go, SearchTree__Insertⁱᵐᵖˡ)]); (Person.id, [("BuggySetAge"%go, Person__BuggySetAgeⁱᵐᵖˡ); ("Name"%go, Person__Nameⁱᵐᵖˡ)]); (ptrT.id Person.id, [("BuggySetAge"%go, (λ: "$r",
                 method_call #Person.id #"BuggySetAge"%go (![#Person] "$r")
                 )%V); ("GetAge"%go, Person__GetAgeⁱᵐᵖˡ); ("Name"%go, (λ: "$r",
                 method_call #Person.id #"Name"%go (![#Person] "$r")
                 )%V); ("Older"%go, Person__Olderⁱᵐᵖˡ)]); (Rect.id, [("Area"%go, Rect__Areaⁱᵐᵖˡ); ("IsSquare"%go, Rect__IsSquareⁱᵐᵖˡ)]); (ptrT.id Rect.id, [("Area"%go, (λ: "$r",
                 method_call #Rect.id #"Area"%go (![#Rect] "$r")
                 )%V); ("IsSquare"%go, (λ: "$r",
                 method_call #Rect.id #"IsSquare"%go (![#Rect] "$r")
                 )%V); ("MakeSquare"%go, Rect__MakeSquareⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo heap.heap :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.std.std];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #heap.heap (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (package.alloc heap.heap #()))
      ).

End code.
End heap.
