(* autogenerated from sys_verif_code/concurrent/barrier *)
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition barrier : go_string := "sys_verif_code/concurrent/barrier".

Module barrier.

Module Barrier. Definition id : go_string := "sys_verif_code/concurrent/barrier.Barrier"%go. End Barrier.

Section code.
Context `{ffi_syntax}.


Definition Barrier : go_type := structT [
  "numWaiting" :: uint64T;
  "mu" :: ptrT;
  "cond" :: ptrT
].
#[global] Typeclasses Opaque Barrier.
#[global] Opaque Barrier.

Definition New : go_string := "sys_verif_code/concurrent/barrier.New"%go.

(* Create a new barrier waiting for no threads.

   go: barrier.go:26:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] "mu")) in
    (func_call #sync.NewCond) "$a0") in
    do:  ("cond" <-[#ptrT] "$r0");;;
    return: (mem.alloc (let: "$numWaiting" := #(W64 0) in
     let: "$mu" := (![#ptrT] "mu") in
     let: "$cond" := (![#ptrT] "cond") in
     struct.make #Barrier [{
       "numWaiting" ::= "$numWaiting";
       "mu" ::= "$mu";
       "cond" ::= "$cond"
     }]))).

(* Add `n` threads that the barrier is waiting to call `Done()`.

   go: barrier.go:33:19 *)
Definition Barrier__Addⁱᵐᵖˡ : val :=
  λ: "b" "n",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "n" := (mem.alloc "n") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b"))) in
    let: "$a1" := (![#uint64T] "n") in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ((struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b")) <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    return: #()).

(* Mark one thread as done.

   go: barrier.go:40:19 *)
Definition Barrier__Doneⁱᵐᵖˡ : val :=
  λ: "b" <>,
    exception_do (let: "b" := (mem.alloc "b") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    (if: (![#uint64T] (struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b"))) = #(W64 0)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Done() called too many times"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := ((![#uint64T] (struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b"))) - #(W64 1)) in
    do:  ((struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b")) <-[#uint64T] "$r0");;;
    (if: (![#uint64T] (struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b"))) = #(W64 0)
    then do:  ((method_call #(ptrT.id sync.Cond.id) #"Broadcast"%go (![#ptrT] (struct.field_ref #Barrier #"cond"%go (![#ptrT] "b")))) #())
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    return: #()).

(* Wait blocks until all threads pending with `Add()` have called `Done()`.

   go: barrier.go:53:19 *)
Definition Barrier__Waitⁱᵐᵖˡ : val :=
  λ: "b" <>,
    exception_do (let: "b" := (mem.alloc "b") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    (for: (λ: <>, (![#uint64T] (struct.field_ref #Barrier #"numWaiting"%go (![#ptrT] "b"))) > #(W64 0)); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] (struct.field_ref #Barrier #"cond"%go (![#ptrT] "b")))) #()));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Barrier #"mu"%go (![#ptrT] "b")))) #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Barrier.id, []); (ptrT.id Barrier.id, [("Add"%go, Barrier__Addⁱᵐᵖˡ); ("Done"%go, Barrier__Doneⁱᵐᵖˡ); ("Wait"%go, Barrier__Waitⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo barrier.barrier :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.goose_lang.std.std];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #barrier.barrier (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc barrier.barrier #()))
      ).

End code.
End barrier.
