(* autogenerated from sys_verif_code/algo *)

From New.golang Require Import defn.
Definition algo : go_string := "sys_verif_code/algo".

Module algo.

Module Person. Definition id : go_string := "sys_verif_code/algo.Person"%go. End Person.

Section code.
Context `{ffi_syntax}.


Definition Person : go_type := structT [
  "Name" :: stringT;
  "Age" :: uint64T
].
#[global] Typeclasses Opaque Person.
#[global] Opaque Person.

Definition Sort : go_string := "sys_verif_code/algo.Sort"%go.

(* Sort sorts arr by increasing Age.

   go: sort.go:9:6 *)
Definition Sortⁱᵐᵖˡ : val :=
  λ: "arr",
    exception_do (let: "arr" := (mem.alloc "arr") in
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "arr") in
    slice.len "$a0")) in
    do:  ("l" <-[#uint64T] "$r0");;;
    let: "l_m_1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "l") - #(W64 1)) in
    do:  ("l_m_1" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "l")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "l_m_1")); (λ: <>, do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: (![#uint64T] (struct.field_ref #Person #"Age"%go (slice.elem_ref #Person (![#sliceT] "arr") (![#uint64T] "j")))) > (![#uint64T] (struct.field_ref #Person #"Age"%go (slice.elem_ref #Person (![#sliceT] "arr") ((![#uint64T] "j") + #(W64 1)))))
        then
          let: "tmp" := (mem.alloc (type.zero_val #Person)) in
          let: "$r0" := (![#Person] (slice.elem_ref #Person (![#sliceT] "arr") (![#uint64T] "j"))) in
          do:  ("tmp" <-[#Person] "$r0");;;
          let: "$r0" := (![#Person] (slice.elem_ref #Person (![#sliceT] "arr") ((![#uint64T] "j") + #(W64 1)))) in
          do:  ((slice.elem_ref #Person (![#sliceT] "arr") (![#uint64T] "j")) <-[#Person] "$r0");;;
          let: "$r0" := (![#Person] "tmp") in
          do:  ((slice.elem_ref #Person (![#sliceT] "arr") ((![#uint64T] "j") + #(W64 1))) <-[#Person] "$r0")
        else do:  #())))));;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(Sort, Sortⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Person.id, []); (ptrT.id Person.id, [])].

#[global] Instance info' : PkgInfo algo.algo :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #algo.algo (λ: <>,
      exception_do (do:  (package.alloc algo.algo #()))
      ).

End code.
End algo.
