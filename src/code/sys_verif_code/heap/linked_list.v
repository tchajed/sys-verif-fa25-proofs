(* autogenerated from sys_verif_code/heap/linked_list *)

From New.golang Require Import defn.
Definition linked_list : go_string := "sys_verif_code/heap/linked_list".

Module linked_list.

Module Node. Definition id : go_string := "sys_verif_code/heap/linked_list.Node"%go. End Node.

Section code.
Context `{ffi_syntax}.


Definition Node : go_type := structT [
  "elem" :: uint64T;
  "next" :: ptrT
].
#[global] Typeclasses Opaque Node.
#[global] Opaque Node.

Definition New : go_string := "sys_verif_code/heap/linked_list.New"%go.

(* go: linked_list.go:8:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#null)).

(* go: linked_list.go:12:16 *)
Definition Node__Insertⁱᵐᵖˡ : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "elem" := (mem.alloc "elem") in
    return: (mem.alloc (let: "$elem" := (![#uint64T] "elem") in
     let: "$next" := (![#ptrT] "l") in
     struct.make #Node [{
       "elem" ::= "$elem";
       "next" ::= "$next"
     }]))).

(* go: linked_list.go:16:16 *)
Definition Node__Popⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    (if: (![#ptrT] "l") = #null
    then return: (#(W64 0), ![#ptrT] "l", #false)
    else do:  #());;;
    return: (![#uint64T] (struct.field_ref #Node #"elem"%go (![#ptrT] "l")), ![#ptrT] (struct.field_ref #Node #"next"%go (![#ptrT] "l")), #true)).

(* go: linked_list.go:23:16 *)
Definition Node__Containsⁱᵐᵖˡ : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "elem" := (mem.alloc "elem") in
    let: "n" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] "l") in
    do:  ("n" <-[#ptrT] "$r0");;;
    (for: (λ: <>, (![#ptrT] "n") ≠ #null); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] (struct.field_ref #Node #"elem"%go (![#ptrT] "n"))) = (![#uint64T] "elem")
      then return: (#true)
      else do:  #());;;
      let: "$r0" := (![#ptrT] (struct.field_ref #Node #"next"%go (![#ptrT] "n"))) in
      do:  ("n" <-[#ptrT] "$r0"));;;
    return: (#false)).

(* go: linked_list.go:34:16 *)
Definition Node__Deleteⁱᵐᵖˡ : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "elem" := (mem.alloc "elem") in
    (if: (![#ptrT] "l") = #null
    then return: (![#ptrT] "l")
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref #Node #"elem"%go (![#ptrT] "l"))) = (![#uint64T] "elem")
    then
      return: (let: "$a0" := (![#uint64T] "elem") in
       (method_call #(ptrT.id Node.id) #"Delete"%go (![#ptrT] (struct.field_ref #Node #"next"%go (![#ptrT] "l")))) "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#uint64T] "elem") in
    (method_call #(ptrT.id Node.id) #"Delete"%go (![#ptrT] (struct.field_ref #Node #"next"%go (![#ptrT] "l")))) "$a0") in
    do:  ((struct.field_ref #Node #"next"%go (![#ptrT] "l")) <-[#ptrT] "$r0");;;
    return: (![#ptrT] "l")).

(* go: linked_list.go:46:16 *)
Definition Node__Appendⁱᵐᵖˡ : val :=
  λ: "l" "other",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "other" := (mem.alloc "other") in
    (if: (![#ptrT] "l") = #null
    then return: (![#ptrT] "other")
    else do:  #());;;
    return: (mem.alloc (let: "$elem" := (![#uint64T] (struct.field_ref #Node #"elem"%go (![#ptrT] "l"))) in
     let: "$next" := (let: "$a0" := (![#ptrT] "other") in
     (method_call #(ptrT.id Node.id) #"Append"%go (![#ptrT] (struct.field_ref #Node #"next"%go (![#ptrT] "l")))) "$a0") in
     struct.make #Node [{
       "elem" ::= "$elem";
       "next" ::= "$next"
     }]))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Node.id, []); (ptrT.id Node.id, [("Append"%go, Node__Appendⁱᵐᵖˡ); ("Contains"%go, Node__Containsⁱᵐᵖˡ); ("Delete"%go, Node__Deleteⁱᵐᵖˡ); ("Insert"%go, Node__Insertⁱᵐᵖˡ); ("Pop"%go, Node__Popⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo linked_list.linked_list :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #linked_list.linked_list (λ: <>,
      exception_do (do:  (package.alloc linked_list.linked_list #()))
      ).

End code.
End linked_list.
