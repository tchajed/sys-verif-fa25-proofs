(* autogenerated from sys_verif_code/functional *)
Require Export New.code.github_com.goose_lang.std.

From New.golang Require Import defn.
Definition functional : go_string := "sys_verif_code/functional".

Module functional.

Section code.
Context `{ffi_syntax}.


Definition Add : go_string := "sys_verif_code/functional.Add"%go.

(* Add returns the sum of a and b

   go: functional.go:6:6 *)
Definition Addⁱᵐᵖˡ : val :=
  λ: "a" "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    return: ((![#uint64T] "a") + (![#uint64T] "b"))).

Definition Max : go_string := "sys_verif_code/functional.Max"%go.

(* Max returns the max of a and b

   go: functional.go:11:6 *)
Definition Maxⁱᵐᵖˡ : val :=
  λ: "a" "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    (if: (![#uint64T] "a") > (![#uint64T] "b")
    then return: (![#uint64T] "a")
    else do:  #());;;
    return: (![#uint64T] "b")).

Definition Midpoint : go_string := "sys_verif_code/functional.Midpoint"%go.

(* go: functional.go:18:6 *)
Definition Midpointⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (((![#uint64T] "x") + (![#uint64T] "y")) `quot` #(W64 2))).

Definition Midpoint2 : go_string := "sys_verif_code/functional.Midpoint2"%go.

(* Midpoint2 calculates the midpoint in an overflow-proof way

   go: functional.go:23:6 *)
Definition Midpoint2ⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: (![#uint64T] "x") ≤ (![#uint64T] "y")
    then return: ((![#uint64T] "x") + (((![#uint64T] "y") - (![#uint64T] "x")) `quot` #(W64 2)))
    else return: ((![#uint64T] "y") + (((![#uint64T] "x") - (![#uint64T] "y")) `quot` #(W64 2))))).

Definition Arith : go_string := "sys_verif_code/functional.Arith"%go.

(* go: functional.go:31:6 *)
Definition Arithⁱᵐᵖˡ : val :=
  λ: "a" "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "a") + (![#uint64T] "b")) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "sum") = #(W64 7)
    then return: (![#uint64T] "a")
    else do:  #());;;
    let: "mid" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "a") in
    let: "$a1" := (![#uint64T] "b") in
    (func_call #Midpoint2) "$a0" "$a1") in
    do:  ("mid" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "mid")).

Definition SumNrec : go_string := "sys_verif_code/functional.SumNrec"%go.

(* SumNrec adds up the numbers from 1 to n, recursively.

   go: functional.go:41:6 *)
Definition SumNrecⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    (if: (![#uint64T] "n") = #(W64 0)
    then return: (#(W64 0))
    else do:  #());;;
    return: ((![#uint64T] "n") + (let: "$a0" := ((![#uint64T] "n") - #(W64 1)) in
     (func_call #SumNrec) "$a0"))).

Definition SumN : go_string := "sys_verif_code/functional.SumN"%go.

(* SumN adds up the numbers from 1 to n, with a loop.

   go: functional.go:49:6 *)
Definition SumNⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") > (![#uint64T] "n")
      then break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#uint64T] "sum") in
      let: "$a1" := (![#uint64T] "i") in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ("sum" <-[#uint64T] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#uint64T] "sum")).

Definition SumN2 : go_string := "sys_verif_code/functional.SumN2"%go.

(* SumN2 is a variation on SumN: it uses a different loop and signed integers

   go: functional.go:63:6 *)
Definition SumN2ⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "n")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#uint64T] "sum") in
      let: "$a1" := (s_to_w64 (![#intT] "i")) in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ("sum" <-[#uint64T] "$r0")));;;
    return: (![#uint64T] "sum")).

Definition Fibonacci : go_string := "sys_verif_code/functional.Fibonacci"%go.

(* Fibonacci returns the nth Fibonacci number

   go: functional.go:72:6 *)
Definition Fibonacciⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    (if: (![#uint64T] "n") = #(W64 0)
    then return: (#(W64 0))
    else do:  #());;;
    let: "fib_prev" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("fib_prev" <-[#uint64T] "$r0");;;
    let: "fib_cur" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("fib_cur" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "fib_next" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((![#uint64T] "fib_cur") + (![#uint64T] "fib_prev")) in
      do:  ("fib_next" <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] "fib_cur") in
      do:  ("fib_prev" <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] "fib_next") in
      do:  ("fib_cur" <-[#uint64T] "$r0")));;;
    return: (![#uint64T] "fib_cur")).

Definition Factorial : go_string := "sys_verif_code/functional.Factorial"%go.

(* Factorial returns n factorial

   go: functional.go:87:6 *)
Definition Factorialⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    (if: (![#uint64T] "n") = #(W64 0)
    then return: (#(W64 1))
    else do:  #());;;
    let: "fact" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("fact" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := ((![#uint64T] "fact") * ((![#uint64T] "i") + #(W64 1))) in
      do:  ("fact" <-[#uint64T] "$r0")));;;
    return: (![#uint64T] "fact")).

Definition FastExp : go_string := "sys_verif_code/functional.FastExp"%go.

(* FastExp returns b to the power of n0

   go: functional.go:101:6 *)
Definition FastExpⁱᵐᵖˡ : val :=
  λ: "b" "n0",
    exception_do (let: "n0" := (mem.alloc "n0") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("a" <-[#uint64T] "$r0");;;
    let: "c" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "b") in
    do:  ("c" <-[#uint64T] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "n0") in
    do:  ("n" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "n") > #(W64 0)); (λ: <>, #()) := λ: <>,
      (if: ((![#uint64T] "n") `rem` #(W64 2)) = #(W64 1)
      then
        let: "$r0" := ((![#uint64T] "a") * (![#uint64T] "c")) in
        do:  ("a" <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "n") `quot` #(W64 2)) in
        do:  ("n" <-[#uint64T] "$r0")
      else
        let: "$r0" := ((![#uint64T] "n") `quot` #(W64 2)) in
        do:  ("n" <-[#uint64T] "$r0"));;;
      let: "$r0" := ((![#uint64T] "c") * (![#uint64T] "c")) in
      do:  ("c" <-[#uint64T] "$r0"));;;
    return: (![#uint64T] "a")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(Add, Addⁱᵐᵖˡ); (Max, Maxⁱᵐᵖˡ); (Midpoint, Midpointⁱᵐᵖˡ); (Midpoint2, Midpoint2ⁱᵐᵖˡ); (Arith, Arithⁱᵐᵖˡ); (SumNrec, SumNrecⁱᵐᵖˡ); (SumN, SumNⁱᵐᵖˡ); (SumN2, SumN2ⁱᵐᵖˡ); (Fibonacci, Fibonacciⁱᵐᵖˡ); (Factorial, Factorialⁱᵐᵖˡ); (FastExp, FastExpⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo functional.functional :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.std.std];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #functional.functional (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (package.alloc functional.functional #()))
      ).

End code.
End functional.
